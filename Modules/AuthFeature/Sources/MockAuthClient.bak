import Foundation
import SharedModels

// Mock implementation of AuthProtocol for testing and development
public struct MockAuthClient: AuthProtocol {
    public init() {}

    // MARK: - Local Mock Data (to avoid MainActor restrictions)1
    
    private func getMockAuthRecord(index: Int) -> AuthenticationRecord {
        return AuthenticationRecord.mockAuthenticationRecords[index]
    }

    // MARK: - Authentication

    public func signIn() async throws -> (user: User, authRecord: AuthenticationRecord) {
        // Simulate network delay
        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

        // Return Graham Hindle (authenticated user) from seed data
        let user = User.mockData[0] // Graham Hindle
        let authRecord = getMockAuthRecord(index: 0) // Password provider

        return (user: user, authRecord: authRecord)
    }

    public func signUp() async throws -> (user: User, authRecord: AuthenticationRecord) {
        // Simulate network delay
        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

        // Return Jane Doe (Google OAuth user) from seed data
        let user = User.mockData[1] // Jane Doe
        let authRecord = getMockAuthRecord(index: 1) // Google OAuth provider

        return (user: user, authRecord: authRecord)
    }

    public func signInAsGuest() async throws -> (user: User, authRecord: AuthenticationRecord) {
        try await Task.sleep(nanoseconds: 200_000_000) // Faster for guest

        // Return Guest User from seed data
        let user = User.mockData[2] // Guest User
        let authRecord = getMockAuthRecord(index: 2) // Guest provider

        return (user: user, authRecord: authRecord)
    }

    public func signOut() async throws {
        try await Task.sleep(nanoseconds: 200_000_000)
        // Mock implementation - no-op
    }

    // MARK: - User Management

    public func getCurrentUser() async -> (user: User, authRecord: AuthenticationRecord)? {
        // Mock implementation - return Graham Hindle as current user
        let user = User.mockData[0] // Graham Hindle
        let authRecord = getMockAuthRecord(index: 0)
        return (user: user, authRecord: authRecord)
    }

    public func deleteAccount() async throws {
        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second - longer for delete
        // Mock implementation - simulate success
    }

    public func resetPassword(email: String) async throws {
        try await Task.sleep(nanoseconds: 500_000_000)

        guard !email.isEmpty else {
            throw AuthError.invalidCredentials
        }

        // Mock implementation - simulate success
    }

    // MARK: - Database Operations

    public func createUser(name: String, email: String) async throws -> User {
        try await Task.sleep(nanoseconds: 300_000_000) // 0.3 seconds

        // Create a new user with the next available ID
        return User(
            id: 4,
            name: name,
            dateOfBirth: nil,
            email: email,
            dateCreated: Date(),
            lastSignedInDate: nil,
            authenticationID: nil
        )
    }

    public func updateUser(_ user: User) async throws -> User {
        try await Task.sleep(nanoseconds: 300_000_000)

        // Return the updated user with current timestamp
        return User(
            id: user.id,
            name: user.name,
            dateOfBirth: user.dateOfBirth,
            email: user.email,
            dateCreated: user.dateCreated,
            lastSignedInDate: Date(), // Update last signed in
            authenticationID: user.authenticationID
        )
    }

    public func getUserById(_ id: Int) async throws -> User? {
        try await Task.sleep(nanoseconds: 200_000_000)

        // Return user from seed data if ID matches
        return User.mockData.first { $0.id == id }
    }

    public func deleteUser(_ id: Int) async throws {
        try await Task.sleep(nanoseconds: 500_000_000) // Longer for delete
        // Mock implementation - simulate successful deletion
    }

    // MARK: - State Management

    public func authStateChanges() -> AsyncStream<(user: User, authRecord: AuthenticationRecord)?> {
        AsyncStream { continuation in
            // Mock implementation - emit current user and finish
            let user = User.mockData[0] // Graham Hindle
            let authRecord = self.getMockAuthRecord(index: 0)
            continuation.yield((user: user, authRecord: authRecord))
            continuation.finish()
        }
    }

    public func updateInMemoryUser(_ user: User, authRecord: AuthenticationRecord) async {
        // Mock implementation - no-op since we don't maintain state
    }
}
